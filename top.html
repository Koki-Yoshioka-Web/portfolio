<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>吸い込まれるオープニング</title>
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        height: 100%;
        background-color: #000;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
      #welcomeText {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-size: 3rem;
        opacity: 0; /* 初期状態は透明 */
        font-family: "Arial", sans-serif;
      }
      #bg {
        opacity: 1;
        transition: opacity 1s ease;
      }
    </style>
  </head>
  <body>
    <canvas id="bg"></canvas>
    <!-- Welcomeのテキスト -->
    <div id="welcomeText">Welcome to My Portfolio</div>

    <!-- Three.jsとGSAPの読み込み -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>

    <script>
      let scene,
        camera,
        renderer,
        stars,
        starGeo,
        objects = [],
        lines = [];

      function init() {
        // シーン、カメラ、レンダラーの設定
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.z = 500; // 遠くからスタート

        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById("bg"),
          antialias: true,
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 星の背景を作成
        addStars();

        // 光のラインを追加（白色）
        addLines();

        // 複数の立体オブジェクトを追加
        addObjects();

        // 吸い込まれるようなオープニングのアニメーション開始
        animateOpening();
      }

      function addStars() {
        // 星のエフェクトを作成
        starGeo = new THREE.BufferGeometry();
        let starVertices = [];
        for (let i = 0; i < 10000; i++) {
          let star = new THREE.Vector3(
            Math.random() * 600 - 300,
            Math.random() * 600 - 300,
            Math.random() * 600 - 300
          );
          starVertices.push(star.x, star.y, star.z);
        }
        starGeo.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(starVertices, 3)
        );
        let starMaterial = new THREE.PointsMaterial({ color: 0xaaaaaa });
        stars = new THREE.Points(starGeo, starMaterial);
        scene.add(stars);
      }

      function addLines() {
        // 複数のラインを画面に追加（色を白に設定）
        let material = new THREE.LineBasicMaterial({ color: 0xffffff }); // 白色
        for (let i = 0; i < 10; i++) {
          let points = [];
          for (let j = 0; j < 5; j++) {
            points.push(
              new THREE.Vector3(
                Math.random() * 800 - 400,
                Math.random() * 800 - 400,
                Math.random() * 800 - 400
              )
            );
          }
          let geometry = new THREE.BufferGeometry().setFromPoints(points);
          let line = new THREE.Line(geometry, material);
          lines.push(line);
          scene.add(line);
        }
      }

      function addObjects() {
        // 複数の立体的なオブジェクトを追加（例：イコサヘドロン）
        const geometry = new THREE.IcosahedronGeometry(20, 0);
        const material = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          wireframe: true,
        });

        for (let i = 0; i < 20; i++) {
          const obj = new THREE.Mesh(geometry, material);
          obj.position.set(
            Math.random() * 800 - 400,
            Math.random() * 800 - 400,
            Math.random() * 800 - 400
          );
          objects.push(obj);
          scene.add(obj);
        }
      }

      function animateOpening() {
        // カメラを中心に向かって吸い込まれるように移動
        gsap.to(camera.position, {
          z: 0,
          duration: 5,
          ease: "power3.inOut", // ゆっくり始まり、急激に加速
          onComplete: function () {
            // テキストのフェードイン
            gsap.to("#welcomeText", {
              opacity: 1,
              duration: 1,
              ease: "power2.inOut",
              onComplete: function () {
                // 2秒後にフェードアウトして、index.htmlに遷移
                gsap.to("#welcomeText", {
                  opacity: 0,
                  duration: 1,
                  delay: 2,
                  onComplete: function () {
                    // 背景のフェードアウト
                    document.getElementById("bg").style.opacity = 0;
                    setTimeout(() => {
                      window.location.href = "index.html"; // index.htmlに遷移
                    }, 1000); // フェードアウトが完了してから遷移
                  },
                });
              },
            });
          },
        });

        // オブジェクトを中心に引き込むアニメーション
        objects.forEach((obj, i) => {
          gsap.to(obj.position, {
            x: 0,
            y: 0,
            z: 0,
            duration: 5,
            ease: "power3.inOut",
            delay: i * 0.05, // 少し遅れて順番に吸い込まれる
          });
        });

        // ラインが徐々に中心に集まるアニメーション
        lines.forEach((line, i) => {
          line.geometry.attributes.position.array.forEach((val, index) => {
            gsap.to(line.geometry.attributes.position.array, {
              [index]: 0,
              duration: 5,
              ease: "power3.inOut",
              delay: i * 0.1,
            });
          });
        });
      }

      function animate() {
        requestAnimationFrame(animate);

        // オブジェクトとラインの回転を追加（軽い回転で動きを加える）
        objects.forEach((obj) => {
          obj.rotation.x += 0.01;
          obj.rotation.y += 0.01;
        });

        lines.forEach((line) => {
          line.rotation.x += 0.005;
          line.rotation.y += 0.005;
        });

        // 星を回転させる
        stars.rotation.x += 0.001;
        stars.rotation.y += 0.001;

        renderer.render(scene, camera);
      }

      init();
      animate();

      // ウィンドウサイズ変更時にレンダラーのサイズを更新
      window.addEventListener("resize", function () {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      });
    </script>
  </body>
</html>
